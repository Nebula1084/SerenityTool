.ORIGIN 0x0		
		addi	$sp, $zero, 0x2FFE #initial the stack pointer
		move	$gp, $zero		
		jal 	init_disk

		jal		dir
		la		$a0, open_name
		jal		exec		
		
exit:	beq $zero, $zero, exit
		.2byte	exit	
open_name:
		.asciiz "A       BIT"
tmp_name:
		.asciiz "12345678123"
		
exec:
		push	$ra
		push	$a0			#exectable name
		push	$v0
		push	$a1
		push	$a2
		
		jal		fopen		
		beq		$v0, $zero, l1		#if file open success
		
		la		$a0, F_LENGTH
		lw		$a0, 0x0($a0)
		srl		$a0, $a0, 1
		li		$a1, 0x1000
		jal		fread
		
		jal		fclose					
		
l1:		move	$a0, $v0
		li		$v0, 4		
		li		$a1, 0
		li		$a2, 0
		
		syscall
		
		li		$gp, 0x1002
		li		$a0, 0x1002
		jr		$a0
		
		pop		$a2
		pop		$a1
		pop		$v0
		pop		$a0
		pop		$ra			
		
		jr		$ra

init_disk:
		push	$s0
		push	$a0
		push	$a1
		push	$a2
		push	$v1
		push	$v0
		push	$t0
		push	$ra
		push	$t1
		push	$t2
		push	$t3
		push	$t4

		#load 0 sector
		li		$a0, 0x0
#		move	$a0, $zero
		jal		load_sector

		li		$t0, 0x5100
		
		lw		$a0, 0xE3($t0)			#Sectors preceding partition 1				
		jal		rever
		la		$t1, psec
		sw		$v0, 0x0($t1)
		

		lw		$a0, 0xE5($t0)			#length of partition 1 in sector
		jal		rever
		la		$t1, plen
		sw		$v0, 0x0($t1)

		#load BPB of first partition
		la		$t1, psec
		lw		$t1, 0x0($t1)
		move	$a0, $t1
		jal		load_sector	
						
		
		#bytes per sector(pbps)
		li		$t0, 0x5100
		lw		$t1, 0x5($t0)	
		sll		$a0, $t1, 8				#only two, I move it to the end of word
		li		$t2, 0xFFFF0000
		and 	$a0, $a0, $t2				
		jal		rever
		move	$a0, $v0
		la		$t1, pbps
		sw		$a0, 0x0($t1)			#pbps = $a0
		
		#sector per cluster(pspc)
		lw		$t1, 0x6($t0)
		move	$a0, $t1
		srl		$a0, $a0, 16
		andi	$a0, $a0, 0x0F
		la		$t1, pspc
		sw		$a0, 0x0($t1)		#pspc
		
		push	$a1
		push	$a2
		push	$v0
		
		pop		$a2
		pop		$a1
		pop		$v0
		
		#reserved sector(prs)
		lw		$t1, 0x7($t0)
		move	$a0, $t1
		jal		rever
		andi	$a0, $v0, 0xFF
		la		$t1, prs
		sw		$a0, 0x0($t1)		#prs
		
		#number of fat
		lw		$t1, 0x8($t0)
		move	$a0, $t1
		jal		rever
		andi	$a0, $v0, 0xFF
		la		$t1, nof
		sw		$a0, 0x0($t1)		#nof
				
		
		#sector per fat
		lw		$t1, 0xb($t0)		
		move	$a0, $t1
		jal		rever
		andi	$a0, $v0, 0xFF
		la		$t1, pspf
		sw		$a0, 0x0($t1)		#pspf

		#hidden sector
		lw		$t1, 0xe($t0)
		move	$a0, $t1
		jal		rever
		move	$a0, $v0
				
		la		$t0, psec
		lw		$t1, 0x0($t0)		#$t1=psec
		la		$t0, prs
		lw		$t2, 0x0($t0)		#$t2=prs
		la		$t0, nof
		lw		$t3, 0x0($t0)		#$t3=nof
		la		$t0, pspf
		lw		$t4, 0x0($t0)		#$t4=pspf			
		
		#load FAT sector
		add		$t0, $t1, $t2		#$a0=psec+prs FAT = psec+prs
		move	$a0, $t0				
		
		jal		load_sector
		li		$a0, 0x3D00
		jal 	mosec				#move fat sector to 0x3D00
		
		mul		$t3, $t3, $t4
		add		$t0, $t0, $t3
		move	$a0, $t0			#$a0=psec+prs+nof*pspf
		
		la		$s0, DIR_sector
		sw		$a0, 0x0($s0)
		
		#load DIR sector
		jal		load_sector
		li		$a0, 0x3E00
		jal		mosec
		
		pop		$t4
		pop		$t3
		pop		$t2
		pop		$t1
		pop		$ra
		pop		$t0
		pop		$v0
		pop		$v1
		pop		$a2
		pop		$a1
		pop		$a0
		pop		$s0
		jr		$ra
		
#load sector
load_sector:
#$a0, number of specifed sector that need to be loaded
		push	$a0
		push	$s0
		
		sw		$a0, 0x50FC($zero)
		addi	$s0, $zero, 2
		sh		$s0, 0x50FE($zero)
SUS_L:	lh		$s0, 0x50FF($zero)
		beq		$s0, $zero, SUS_L
		
		la		$s0, SYS_SEC_BUF
		sw		$a0, 0x0($s0)
		
		pop		$a0
		pop		$s0
		jr		$ra
		
dump_sector:
#$a0, number of specifed sector that need to be loaded
		push	$a0
		push	$s0
		
		sw		$a0, 0x50FC($zero)
		addi	$s0, $zero, 1
		sh		$s0, 0x50FE($zero)
SUS_D:	lh		$s0, 0x50FF($zero)
		beq		$s0, $zero, SUS_L				
		
		pop		$s0
		pop		$a0
		jr		$ra

#reverse the little-endian data
#$a0 -> $v0
rever:	push	$a0
		push	$t0
		push	$t1
		push	$t2
		push	$t3
		push	$ra
		
		andi	$t0, $a0, 0xFF
		srl		$t1, $a0, 8
		andi	$t1, $t1, 0xFF
		srl		$t2, $a0, 16
		andi	$t2, $t2, 0xFF
		srl		$t3, $a0, 24
		andi 	$t3, $t3, 0xFF
		sll		$v0, $t0, 24
		sll		$t1, $t1, 16
		sll		$t2, $t2, 8
		add		$v0, $v0, $t1
		add		$v0, $v0, $t2
		add		$v0, $v0, $t3
		
		pop		$ra
		pop		$t3
		pop		$t2
		pop		$t1
		pop		$t0
		pop		$a0
		jr		$ra
		
DIR_sector:
		.2byte	0x0
psec:	.2byte	0x0
plen:	.2byte	0x0
pbps:	.2byte	0x0
#sector per cluster
pspc:	.2byte	0x0
prs:	.2byte	0x0
nof:	.2byte	0x0
pspf:	.2byte	0x0

#move sector
mosec:	push	$a0
		push	$t0
		push	$t1
		push	$t2
		push	$t3
		push	$t4
		push	$ra
		
		li 		$t0, 0x5100
		move	$t1, $a0
		li		$t2, 0x100
		move	$t3, $zero

mv:		lw		$t4, 0($t0)		# for (i=0; i<100; i++)
		sw		$t4, 0($t1)		#	s[$t1]=s[$t0]
		addi	$t0, $t0, 1
		addi	$t1, $t1, 1
		addi	$t2, $t2, -1
		bne		$t2, $zero, mv
		
		pop		$ra
		pop		$t4
		pop		$t3
		pop		$t2
		pop		$t1
		pop		$t0
		pop 	$a0
		
		jr		$ra
	
#------------dir command-------------------	
dir:	push	$ra
		push	$t0
		push	$t1
		push	$t2
		push	$t3
		push	$t4
		push	$t5
		push	$a2
		push	$a1
		push	$a0				
		push	$v0
		push	$s0
		push	$s1
				
		li		$t0, 0x3E00
		move	$t1, $zero
		li		$t2, 16
s_dir:	mul		$t3, $t1, $t2		#while(dir[0]!=0)
		add		$t4, $t3, $t0
		
		lw		$t5, 0x0($t4)
		beq		$t5, $zero, s_fin
		move	$a0, $t5
		move	$a1, $t1			#$a1 line number
		li		$a2, 0
		li		$v0, 4
				
		addi	$t5, $t4, 5			#property
		lh		$t5, 0x0($t5)		#$t5 P
		
		addi	$t1, $t1, 1			#initial cluster
		addi	$t6, $t4, 13		#$t6 I
		lh		$t6, 0x0($t6)
		
		andi	$t5, $t5, 0xFF
		li		$s0, 0x20			# if( P&0xFF != | I == 0 ) continue
		bne		$t5, $s0, s_dir
		beq		$t6, $zero, s_dir	
		move	$a3, $t4
		jal		p_n
		j		s_dir
s_fin:	
		pop		$s1
		pop		$s0
		pop		$v0
		pop		$a0
		pop		$a1
		pop		$a2
		pop		$t5
		pop		$t4
		pop		$t3
		pop		$t2
		pop		$t1
		pop		$t0
		pop		$ra
		jr		$ra

#-----------print name------------------
p_n:	
		push	$a0
		push	$a1
		push	$ra
		push	$a2
		push	$a3
		push	$v0
		push	$t0
		push	$t1
		push	$t2
		push	$s0
		push	$s1
		push	$s3
		push	$s4
		
		move	$s4, $a1			#line number
		li		$s3, 0x20
		la		$t1, ln				#dest
		move	$t2, $a3			#source
f_nam:	lh		$t0, 0x0($t2)
		srl		$s1, $t0, 8			#high 8 bit
		beq		$s1, $s3, f_ext		#if ($s1==' ') break;		
		sh		$s1, 0x0($t1)
		addi	$t1, $t1, 1
		andi	$s2, $t0, 0x0FF		#low 8 bit
		
		beq		$s2, $s3, f_ext		#if ($s1==' ') break;
		sh		$s2, 0x0($t1)
		addi	$t1, $t1, 1	
		addi	$t2, $t2, 1
			 		
		j		f_nam

f_ext:	li		$s0, 0x2E
		sh		$s0, 0x0($t1)
		addi	$t1, $t1, 1
		sh		$zero, 0x0($t1)
		
		addi	$t2, $a3, 4
		
		lh		$t0, 0x0($t2)
		srl		$s1, $t0, 8			#high 8 bit
		beq		$s1, $s3, f_p		#if ($s1==' ') break;		
		sh		$s1, 0x0($t1)
		addi	$t1, $t1, 1
		andi	$s2, $t0, 0x0FF		#low 8 bit		
		beq		$s2, $s3, f_p		#if ($s1==' ') break;
		sh		$s2, 0x0($t1)
		addi	$t1, $t1, 1	
		addi	$t2, $t2, 1

		lh		$t0, 0x0($t2)
		srl		$s1, $t0, 8			#high 8 bit
		beq		$s1, $s3, f_p		#if ($s1==' ') break;		
		sh		$s1, 0x0($t1)
		addi	$t1, $t1, 1
		sh		$zero, 0x0($t1)


f_p:	la		$a0, ln
		li		$a2, 40
		mul		$a1, $a2, $s4
		li		$v0, 1	
		syscall
			
		pop		$s4
		pop		$s3		
		pop		$s1
		pop		$s0
		pop		$t2
		pop		$t1
		pop		$t0
		pop		$v0
		pop		$a3
		pop		$a2
		pop		$ra
		pop		$a1
		pop		$a0
		
		jr		$ra

ln:		.asciiz	"12345678.123"

lt:		.asciiz	"12345678.123"

#-------------------fopen------------------
fopen:
#	$a0, pointer to input string
#	$v0, return value which indicate whether open operation success or not
#			@success: 1		@error: 0

		push	$a0
		push	$a1
		push	$a2
		push	$ra
		push	$t0
		push	$t1
		push	$t2
		push	$t3
		push	$t4
		push	$t5
		push	$t6
		push	$s0
		push	$s1		
		
		move	$s1, $a0				#file name
		
		la		$t0, F_OPEN
		lw		$t1, 0x0($t0)			#check whether file pointer has been initialized
		beq		$t1, $zero, open_file	#if file hasn't been opened
		move	$v0, $zero
		j		open_exit
		
open_file:				
		
		li		$t0, 0x3E00
		move	$t1, $zero
		li		$t2, 16
o_dir:	mul		$t3, $t1, $t2		#while(dir[0]!=0)
		add		$t4, $t3, $t0		#$t4 head of each line
		
		lw		$t5, 0x0($t4)
		beq		$t5, $zero, file_not_exist
		move	$a0, $t5
		move	$a1, $t1			#$a1 line number
		li		$a2, 0
		li		$v0, 4
		
		addi	$t5, $t4, 5			#property
		lh		$t5, 0x0($t5)		#$t5 P
		
		addi	$t1, $t1, 1			#initial cluster
		addi	$t6, $t4, 13		#$t6 I
		lh		$t6, 0x0($t6)
		
		andi	$t5, $t5, 0xFF
		li		$s0, 0x20			# if( P&0xFF != | I == 0 ) continue
		bne		$t5, $s0, o_dir
		beq		$t6, $zero, o_dir
		
		move	$a0, $t4
		la		$a1, tmp_name
		jal		split_str
		
		move	$a0, $s1				
		jal		comp_str			#check whether the file exists
		beq		$v0, $zero, o_dir
		beq		$zero, $zero, file_exist
		j		o_dir
#------------not exists--------------
file_not_exist:
		li		$a0, 11
		li		$a1, 11
		li		$a2, 0
		li		$v0, 4
		syscall
		beq		$zero, $zero, open_exit
#-----------exists----------
file_exist:
		
		la		$a0, F_OPEN
		li		$a1, 1
		sw		$a1, 0x0($a0)
		
		la		$a0, F_OFFSET		#$a0 = F_OFFSET
		sw		$zero, 0x0($a0)
		
		sll		$t6, $t6, 16
		move	$a0, $t6
		
		jal		rever				#change I which is initial cluster to big-endian
		move	$t6, $v0
		
		la		$a0, F_INCLT
		sw		$t6, 0x0($a0)
		
		addi	$t6, $t4, 14
		lw		$a0, 0x0($t6)		#extract file length
		jal		rever		
		
		la		$a0, F_LENGTH		
		sw		$v0, 0x0($a0)				
		
		la		$a0, F_INCLT
		lw		$a0, 0x0($a0)
		jal		cal_ini_cluster_sector				
		
		move	$a0, $v0
		jal		load_sector
		
		li		$v0, 1
open_exit:
				
		pop		$s1
		pop		$s0
		pop		$t6
		pop		$t5
		pop		$t4
		pop		$t3
		pop		$t2
		pop		$t1
		pop		$t0
		pop		$ra
		pop		$a2
		pop		$a1
		pop		$a0
		
		jr		$ra
		
F_OPEN:			.2byte	0x0
F_NAME:			.asciiz "12345678123"
F_OFFSET:		.2byte	0x0
F_LENGTH:		.2byte	0x0
F_INCLT:		.2byte	0x0
SYS_SEC_BUF:	.2byte	0x0

split_str:
#	$a0, source which is a file name in 8.3 format
#	$a1, dest

		push	$ra
		push	$t1
		push	$t2
		push	$t3
		push	$t0
		push	$s0
		push	$s1
		push	$s2
		
		move	$t1, $a1				#dest
		move	$t2, $a0				#source
		li		$t3, 4
split_nam:		
		lh		$t0, 0x0($t2)
		srl		$s1, $t0, 8			#high 8 bit				
		sh		$s1, 0x0($t1)
		addi	$t1, $t1, 1
		andi	$s2, $t0, 0x0FF		#low 8 bit		
		sh		$s2, 0x0($t1)
		addi	$t1, $t1, 1	
		addi	$t2, $t2, 1
		addi	$t3, $t3, -1
		bne		$t3, $zero, split_nam			 				

split_ext:									
		lh		$t0, 0x0($t2)
		srl		$s1, $t0, 8			#high 8 bit		
		sh		$s1, 0x0($t1)
		addi	$t1, $t1, 1
		andi	$s2, $t0, 0x0FF		#low 8 bit				
		sh		$s2, 0x0($t1)
		addi	$t1, $t1, 1	
		addi	$t2, $t2, 1

		lh		$t0, 0x0($t2)
		srl		$s1, $t0, 8			#high 8 bit				
		sh		$s1, 0x0($t1)
		addi	$t1, $t1, 1
		sh		$zero, 0x0($t1)
		
		pop		$s2
		pop		$s1
		pop		$s0
		pop		$t0
		pop		$t3
		pop		$t2
		pop		$t1
		pop		$ra
		
		jr		$ra

comp_str:
#	$a0, pointer to first string waiting to be compared
#	$a1, pointer to second string waiting to be compared
#	$v0, return value that indicate whether two string are same or not
#		@match: 1		@not match: 0
		push	$ra
		push	$a0
		push	$a1
		push	$t0
		push	$t1
		
		move	$v0, $zero
cmp_loop:	
		lh		$t0, 0x0($a0)
		lh		$t1, 0x0($a1)
		
		bne		$t0, $t1, cmp_over		#check whether two byte is equal or name
		beq		$t0, $zero, cmp_finish	#finish when attain zero
		beq		$t1, $zero, cmp_finish
		addi	$a0, $a0, 1
		addi	$a1, $a1, 1
		
		j		cmp_loop
		
cmp_finish:
		li		$v0, 1
cmp_over:		
		pop		$t1
		pop		$t0
		pop		$a1
		pop		$a0
		pop		$ra
		
		jr		$ra

fseek:	push	$ra
		pop		$ra

fread:
		push	$a0						#read bytes number
		push	$a1						#destination, pdest
		push	$ra
		push	$t0
		push	$t1
		push	$t2
		push	$t3						#OFFSET
		push	$t4
		push	$s0
		push	$s1
		push	$s2		
		
		move	$s2, $a0			#$s2, byte number that need to be read, C
		la		$t0, F_OPEN
		lw		$t1, 0x0($t0)				#check whether file pointer has been initialized
		bne		$t1, $zero, f_read			#if file hasn't been opened
		li		$v0, 0xFFFFFFFF
		j		fread_32_exit
f_read:
		la		$t0, F_OFFSET
		move	$t4, $t0		
		lw		$t0, 0x0($t0)
		move	$t1, $t0
		move	$t3, $t0
		srl		$t0, $t0, 9			# current sector
		andi	$t1, $t1, 0x1FF		# sector offset				
		
		move	$a0, $t0
		jal		next_cluster
		
		move	$a0, $v0
		jal		cal_ini_cluster_sector				
				
		add		$t0, $zero, $v0
			
		la		$t2, SYS_SEC_BUF
		lw		$t2, 0x0($t2)
#----whether current sector need to be swapped
		beq		$t0, $t2, no_need_swap
need_swap:
		move	$a0, $t2
		jal		dump_sector
		move	$a0, $t0
		jal		load_sector		
no_need_swap:
		beq		$s2, $zero, fread_32_exit
		lw		$v0, 0x5100($t1)
		sw		$v0, 0x0($a1)			#move data to *pdest
		addi	$s2, $s2, -2			#C--
		addi	$a1, $a1, 2				#pdest++
		addi	$t1, $t1, 2				#offset++
		addi	$t3, $t3, 2				#OFFSET++
		li		$t2, 256
		bne		$t1, $t2, fread_L1		#if offset == 256
		sw		$t3, 0x0($t4)			#save OFFSET
		beq		$zero, $zero, f_read
fread_L1:								
		beq		$zero, $zero, no_need_swap
fread_32_exit:		
		pop		$s2
		pop		$s1
		pop		$s0
		pop		$t4
		pop		$t3
		pop		$t2
		pop		$t1
		pop		$t0
		pop		$ra
		pop		$a1
		pop		$a0
		jr		$ra
		
cal_ini_cluster_sector:
#$a0: dest cluster
#$v0: initial cluster for file
		push	$ra
		push	$s0
		push	$s1
		push	$s2
		
		la		$s0, DIR_sector
		lw		$s0, 0x0($s0)		#$s0 = DIR +32
		addi	$s0, $s0, 32
		move	$s1, $a0
		addi	$s1, $s1, -2		#s1 = dest cluster-2
		la		$s2, pspc
		lw		$s2, 0x0($s2)
		mul		$s1, $s1, $s2
		add		$v0, $s0, $s1		#DIR+32+(dest cluster-2)*sector per cluster
		
		pop		$s2
		pop		$s1
		pop		$s0
		pop		$ra
		jr		$ra
		
next_cluster:
#$a0: dest cluster
#0x3D00 fat table
		push	$ra
		push	$a0
		push	$a1
		push	$a2		
		push	$t0
		push	$t1
		push	$s0
		push	$s1					#count

		move	$s1, $a0

		la		$t0, F_INCLT		#$t0, initial cluster
		lw		$t0, 0x0($t0)
		la		$t1, pspc			#$t1, sector per cluster
		lw		$t1, 0x0($t1)
				
nxt_clt_loop:
		ble		$s1, $zero, nxt_clt_exit
		lh		$s0, 0x3D00($t0)	# $S0=CLUSTER[$T0]
		sll		$a0, $s0, 16
		jal		rever
		sub		$s1, $s1, $t1
		move	$t0, $a0
		beq		$zero, $zero, nxt_clt_loop		
nxt_clt_exit:		
		move	$v0, $t0
		
		pop		$s1
		pop		$s0
		pop		$t1
		pop		$t0
		pop		$a2
		pop		$a1
		pop		$a0								
		pop		$ra
		
		jr		$ra
		
fwrite:	push	$ra
		pop		$ra
		jr		$ra

fclose:	push	$ra
		push	$t1
		push	$t2
		
		la		$t2, SYS_SEC_BUF
		lw		$t2, 0x0($t2)
		jal		dump_sector
		
		la		$t1, F_OPEN		
		sw		$zero, 0x0($t1)
		
		pop		$t2
		pop		$t1
		pop		$ra
		jr		$ra