.ORIGIN 0x4000
		.2byte print		# print
		.2byte printstr   	# printstr
    	.2byte putchar   	# putchar
		.2byte getchar	 	# getchar
		.2byte printint		# printint
		.2byte 0x4280	# init_disk
		.2byte 0x4300	# clear

print:	#---------------------syscall print
		push	$a0				#$a0, character that would be printed
		push	$a1				#$a1, the offset to which the character would output
		
		addi	$a1, $a1, 0x3000
		sh		$a0, 0($a1)
		
		pop		$a1
		pop		$a0
		jr		$ra

# syscall $v0 = 0
# a0 ASCII of the char to be output	

printstr: #------------------------syscall printstr
			push	$a0, $a1, $t0, $t5, $t6, $t7
		
			addi	$a1, $a1, 0x3000	# the target address
			li		$t7, 0x000D			# printstr_LINEFEED
			li		$t6, 41				# length of one line	
			move	$t5, $zero 			# counter		
			
printstr_LOOP:
			lh		$t0, 0($a0)			# get character
			addi	$t5, $t5, 1
			bne		$t5, $t6, printstr_GO_ON
			move	$t5, $zero
printstr_GO_ON:		
			beq		$t0, $zero, printstr_EXIT
			beq		$t0, $t7, printstr_LINEFEED  
			sh		$t0, 0($a1)			# print
			addi	$a0, $a0, 1
			addi	$a1, $a1, 1			# move to next
			j		printstr_LOOP

printstr_LINEFEED:	
			sh		$zero, 0($a1)
			beq		$t5, $t6, printstr_EXITLF
			addi	$a1, $a1, 1
			addi	$t5, $t5, 1
			j 		printstr_LINEFEED
			
printstr_EXITLF:		
			addi	$a0, $a0, 1
			move	$t5, $zero	
			j		printstr_LOOP
		
printstr_EXIT:		
			sh		$zero, 0($a1)
			move	$t5, $zero
printstr_CLEARLOOP:  
			addi	$t5, $t5, 1
			addi	$a1, $a1, 1
			sh		$zero, 0($a1)
			bne		$t5, $t6, printstr_CLEARLOOP
			pop		$a0, $a1, $t0, $t5, $t6, $t7
			jr		$ra
		
# syscall $v0 = 1
# $a0 address of the string
# $a1 offset from the Video memory

putchar: #----------------------syscall putchar
		push	$a0				#$a0, character that would be printed
		push	$a1				#$a1, x
		push	$a2				#$a2, y
		push	$t0
		addi	$t0, $zero, 40  # width of the screen
		mul		$a1, $a1, $t0
		add		$a1, $a1, $a2
		addi	$a1, $a1, 0x3000
		sh		$a0, 0($a1)
		
		pop		$t0
		pop		$a2
		pop		$a1
		pop		$a0
		jr		$ra
		
# syscall $v0 = 2


getchar: #-------------------------syscall getchar
# $s0	BUFFER
# $s1	mem[IN]
# $s2	OUT
# $s3	mem[OUT]
                push    $s0
                push    $s1
                push    $s2
                push    $s3
                push    $t0
        
                li		$s0, 0x4706		# $s0 = BUFFER
		li		$s2, 0x4704		# $s2 = OUT
		lw		$s3, 0($s2)		# $s3 = mem[OUT]
getchar_LOOP:	
		lw		$s1, 0x4702($zero)		# $s1 = mem[IN]
		beq		$s1, $s3, getchar_LOOP

		add 	$t0, $s3, $s0
		lw		$a0, 0($t0)		# $a0 = mem[OUT + BUFFER]

		addi    $s3, $s3, 1         # $s3 = mem[OUT] + 1
                sltiu   $t0, $s3, 16
                beq     $t0, $zero, getchar_SUB     # if($s3 >= 16) goto SUB;
                beq     $zero, $zero, getchar_NOT_SUB # else goto NOT_SUB;
getchar_SUB:
                li      $s3, 0              # $s3 = $s3 % 16
getchar_NOT_SUB:
		sw		$s3, 0($s2)

                pop     $t0
                pop     $s3
                pop     $s2
                pop     $s1
                pop     $s0
                jr      $ra
				
printint:	#------------------------syscall printint
#printINT
#a0 int
#a1 X
#a2 Y 

#s0 COUNT
#s1 MASK
#s2 Table
#s3 index
#syscall $v0 = 4
                push    $s0
                push    $s1
                push    $s2
                push    $s3
                push    $t0
                push    $a0

                li      $s0, 32
                li      $s1, 0x0000000F
                li      $t0, 40
                mul     $s3, $a1, $t0
                add     $s3, $s3, $a2
                addi    $s3, $s3, 0x3000
                la      $s2, printint_TABLE
                
printint_LOOP:
                addi    $s0, $s0, -4
                srlv    $t0, $a0, $s0
                and     $t0, $t0, $s1
                add     $t0, $t0, $t0
                add     $t0, $t0, $s2
                lw      $t0, 0($t0)
                sh      $t0, 0($s3)
                addi    $s3, $s3, 1
                beq     $s0, $zero, printint_END
                beq     $zero, $zero, printint_LOOP
printint_END:
                pop     $a0
                pop     $t0
                pop     $s3
                pop     $s2
                pop     $s1
                pop     $s0
                jr      $ra

printint_TABLE:
        .2Byte  0x30
        .2Byte  0x31
        .2Byte  0x32
        .2Byte  0x33
        .2Byte  0x34
        .2Byte  0x35
        .2Byte  0x36
        .2Byte  0x37
        .2Byte  0x38
        .2Byte  0x39
        .2Byte  0x41
        .2Byte  0x42
        .2Byte  0x43
        .2Byte  0x44
        .2Byte  0x45
        .2Byte  0x46